# postgres
#spring.datasource.url= jdbc:postgresql://${embedded.postgresql.host}:${embedded.postgresql.port}/${embedded.postgresql.schema}
# Toxic ??
spring.datasource.url= jdbc:postgresql://${embedded.postgresql.toxiproxy.host}:${embedded.postgresql.toxiproxy.port}/${embedded.postgresql.schema}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username= ${embedded.postgresql.user}
spring.datasource.password= ${embedded.postgresql.password}
# for p6spy-spring-boot-starter in pom.xml
decorator.datasource.p6spy.log-format=%(executionTime) ms|%(category)|connection%(connectionId)|%(sqlSingleLine)


# if you remove this, multiple schedulers can fire at the same time due to
#  multiple cached Spring Contexts started in parallel
scheduling.enabled=false

# wiremock
safety.service.url.base=http://${embedded.wiremock.host}:${embedded.wiremock.port}
email.sender.url.base=http://${embedded.wiremock.host}:${embedded.wiremock.port}

# kafka
spring.kafka.bootstrap-servers=${embedded.kafka.saslPlaintext.brokerList}
spring.kafka.security.protocol=SASL_PLAINTEXT
spring.kafka.properties.sasl.mechanism=PLAIN
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
username="${embedded.kafka.saslPlaintext.user}" \
password="${embedded.kafka.saslPlaintext.password}";


# avoid losing messages sent before test listener connects
spring.kafka.consumer.auto-offset-reset=earliest

# Spring reuses the context in a cache between test classes
# To optimize Spring Context reuse between test classes:
# 1: uncomment next line and rerun **all** your tests
#logging.level.org.springframework.test.context.cache=DEBUG
# 2: Find the last line like this, and see missCount=???? x 10..30 seconds
# Spring test ApplicationContext cache statistics: [... size = 2, maxSize = 32, parentContextCount = 0, hitCount = 102, missCount = 4]
# 3: Find all lines containing "Storing ApplicationContext". The test class that ran before it forced Spring to reboot.
